" Dash
noremap <silent> <leader>d <Plug>DashSearch
let g:dash_map = {
  \ 'stylus' : ['css', 'stylus']
  \ }

" deoplete
let g:deoplete#enable_at_startup = 1

" neomake
noremap <leader>o :lopen<CR> " open location window
noremap <leader>c :lclose<CR> " close location window
noremap <leader>l :ll<CR>         " go to current error/warning
noremap <leader>n :lnext<CR>      " next error/warning
noremap <leader>p :lprev<CR>      " previous error/warning
let g:neomake_javascript_enabled_makers = ['standard']
let g:neomake_php_enabled_makers = ['phpmd']
autocmd! BufWritePre * Neomake
autocmd! QuitPre * let g:neomake_verbose = 0

" UltiSnips
" let g:UltiSnipsExpandTrigger       = '<tab>'
let g:UltiSnipsListSnippets        = '<s-tab>'
let g:UltiSnipsJumpForwardTrigger  = '<C-j>'
let g:UltiSnipsJumpBackwardTrigger = '<C-k>'
let g:UltiSnipsEditSplit           = 'vertical'

" vimtex
let g:vimtex_view_general_viewer
      \ = '/Applications/Skim.app/Contents/SharedSupport/displayline'
let g:vimtex_view_general_options = '-r @line @pdf'

" This adds a callback hook that updates Skim after compilation
let g:vimtex_latexmk_callback_hook = 'UpdateSkim'
function! UpdateSkim(status)
  if !a:status | return | endif

  let l:out = b:vimtex.out()
  let l:cmd = [g:vimtex_view_general_viewer, '-r']
  if !empty(system('pgrep Skim'))
    call extend(l:cmd, ['-g'])
  endif
  if has('nvim')
    call jobstart(l:cmd + [line('.'), l:out])
  elseif has('job')
    call job_start(l:cmd + [line('.'), l:out])
  else
    call system(join(l:cmd + [line('.'), shellescape(l:out)], ' '))
  endif
endfunction

" vim:foldmethod=marker:foldlevel=0:ft=vim
